$-mui-queue: ();

%animated-element {
  animation-play-state: paused;
  animation-fill-mode: both;

  .is-animating & {
    animation-play-state: running;
  }
}

/// Creates a new animation queue.
@mixin mui-series() {
  $-mui-queue: () !global;
  @content;
}

/// Injects a delay into an animation queue.
/// @param {Number} $length - Amount of time in seconds or milliseconds to delay.
@mixin mui-delay($length) {
  $item: ($length, 0s);
  $-mui-queue: append($-mui-queue, $item) !global;
}

/// Adds an animation to the queue.
/// @param {Map} $keyframes - Motion UI keyframes map to use.
/// @param {Number} $duration [1s] - Length of the animation.
/// @param {Number} $gap [0s] - Amount of time to pause before playing the animation after this one.
/// @param {Keyword} $easing [linear] - Timing function to use.
@mixin mui-queue(
  $keyframes, 
  $duration: 1s, 
  $gap: 0s,
  $easing: linear
) {
  // Calculate the delay for this animation based on how long the previous ones take
  $actual-delay: 0s;
  @each $anim in $-mui-queue {
    $actual-delay: $actual-delay + nth($anim, 1) + nth($anim, 2);
  }

  // Append this animation's length and gap to the end of the queue
  $item: ($duration, $gap);
  $-mui-queue: append($-mui-queue, $item) !global;
  
  // CSS output
  @extend %animated-element;
  @include mui-keyframes($keyframes);
  animation-name: map-get($keyframes, name);
  animation-duration: $duration;
  animation-delay: $actual-delay;
  animation-timing-function: $easing;
}